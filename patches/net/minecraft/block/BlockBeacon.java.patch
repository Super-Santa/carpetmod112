--- ../src-base/minecraft/net/minecraft/block/BlockBeacon.java
+++ ../src-work/minecraft/net/minecraft/block/BlockBeacon.java
@@ -1,5 +1,6 @@
 package net.minecraft.block;
 
+import carpet.utils.Data;
 import net.minecraft.block.material.MapColor;
 import net.minecraft.block.material.Material;
 import net.minecraft.block.state.IBlockState;
@@ -20,6 +21,12 @@
 import net.minecraft.world.WorldServer;
 import net.minecraft.world.chunk.Chunk;
 
+import carpet.CarpetSettings;
+import test.AccurateTimer;
+import test.Test;
+
+import java.util.ArrayList;
+
 public class BlockBeacon extends BlockContainer
 {
     public BlockBeacon()
@@ -93,25 +100,43 @@
             ((TileEntityBeacon)tileentity).func_174908_m();
             p_189540_2_.func_175641_c(p_189540_3_, this, 1, 0);
         }
+
+        if (CarpetSettings.asyncBeaconUpdates && p_189540_2_.func_175640_z(p_189540_3_))
+        {
+            ArrayList<Long> localTimes = new ArrayList<>(255);
+            Data.times.add(localTimes);
+
+            //HttpUtil.DOWNLOADER_EXECUTOR.submit(() -> worldIn.notifyNeighborsRespectDebug(pos, this, true));
+            HttpUtil.field_180193_a.submit(() -> {
+                Data.threadArray.set(localTimes);
+                Data.mainThread.set(true);
+                System.out.println("thread started");
+                p_189540_2_.func_175722_b(p_189540_3_, this, true);
+                System.out.println("thread ended");
+            });
+        }
     }
 
     public static void func_176450_d(final World p_176450_0_, final BlockPos p_176450_1_)
     {
+        ArrayList<Long> localTimes = new ArrayList<>(255);
+        Data.times.add(localTimes);
+
         HttpUtil.field_180193_a.submit(new Runnable()
         {
             public void run()
             {
+                Data.threadArray.set(localTimes);
+                Data.mainThread.set(true);
                 Chunk chunk = p_176450_0_.func_175726_f(p_176450_1_);
 
                 for (int i = p_176450_1_.func_177956_o() - 1; i >= 0; --i)
                 {
                     final BlockPos blockpos = new BlockPos(p_176450_1_.func_177958_n(), i, p_176450_1_.func_177952_p());
-
                     if (!chunk.func_177444_d(blockpos))
                     {
                         break;
                     }
-
                     IBlockState iblockstate = p_176450_0_.func_180495_p(blockpos);
 
                     if (iblockstate.func_177230_c() == Blocks.field_150461_bJ)
@@ -134,4 +159,96 @@
             }
         });
     }
+
+    public static void updateColorAsync2(final World worldIn, final BlockPos glassPos)
+    {
+        boolean glassRemoved = Test.isGlassRemoved;
+        //Test.profileResults.put("thread_scheduled", System.nanoTime());
+        HttpUtil.field_180193_a.submit(new Runnable()
+        {
+            public void run()
+            {
+                if (glassRemoved) {
+                    long time = AccurateTimer.rdtsc();
+                    if (!Test.isFirstBeacon) {
+                        Test.isFirstBeacon = true;
+                        Test.profileResults.put("first_beacon_start", time);
+                    }
+                    Test.profileResults.put("last_beacon_start", time);
+                    if (Test.wasRehashChunkLoaded) {
+                        if (!Test.loggedRehashBeacon) {
+                            Test.loggedRehashBeacon = true;
+                            Test.profileResults.put("after_rehash_beacon_start", time);
+                        }
+                    }
+                    else {
+                        Test.profileResults.put("before_rehash_beacon_start", time);
+                    }
+                }
+//                Object[] values;
+//                int mask;
+//                try {
+//                    values = CommandLoadedChunks.getValues((Long2ObjectOpenHashMap) ((ChunkProviderServer) worldIn.getChunkProvider()).loadedChunks).clone();
+//                    mask = CommandLoadedChunks.getMask((Long2ObjectOpenHashMap) ((ChunkProviderServer) worldIn.getChunkProvider()).loadedChunks);
+//                } catch (Exception e) {
+//                    return;
+//                }
+                Chunk chunk = worldIn.func_175726_f(glassPos);
+
+                int i;
+                for (i = glassPos.func_177956_o() - 1; i >= 0; --i)
+                {
+                    final BlockPos blockpos = new BlockPos(glassPos.func_177958_n(), i, glassPos.func_177952_p());
+
+                    if (!chunk.func_177444_d(blockpos))
+                    {
+                        break;
+                    }
+
+                    IBlockState iblockstate = worldIn.func_180495_p(blockpos);
+
+                    if (iblockstate.func_177230_c() == Blocks.field_150461_bJ)
+                    {
+                        ((WorldServer)worldIn).func_152344_a(new Runnable()
+                        {
+                            public void run()
+                            {
+                                TileEntity tileentity = worldIn.func_175625_s(blockpos);
+
+                                if (tileentity instanceof TileEntityBeacon)
+                                {
+                                    ((TileEntityBeacon)tileentity).func_174908_m();
+                                    worldIn.func_175641_c(blockpos, Blocks.field_150461_bJ, 1, 0);
+                                }
+                            }
+                        });
+                    }
+                }
+                //Test.profileResults.put("beacon_end", System.nanoTime());
+//                int index = (int) HashCommon.mix(ChunkPos.asLong(glassPos.getX() >> 4, glassPos.getZ() >> 4)) & mask;
+//                System.out.println(index);
+//                while (values[index] != null) {
+//                    Chunk c = (Chunk) values[index];
+//                    System.out.println("- " + c.x + ", " + c.z);
+//                    index = (index + 1) & mask;
+//                }
+//                System.out.println(glassPos.getY() - i);
+                if (glassRemoved) {
+                    long time = AccurateTimer.rdtsc();
+                    Test.profileResults.put("last_beacon_end", time);
+                    if (!Test.wasRehashChunkLoaded) {
+                        Test.profileResults.put("before_rehash_beacon_end", time);
+                    }
+                    else {
+
+                        if (!Test.loggedRehashBeaconEnd) {
+                            Test.loggedRehashBeaconEnd = true;
+                            Test.profileResults.put("after_rehash_beacon_start", time);
+                        }
+                    }
+                }
+            }
+        });
+        //Test.profileResults.put("thread_scheduling_done", System.nanoTime());
+    }
 }
